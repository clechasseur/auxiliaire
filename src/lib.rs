//! TODO

#![deny(missing_docs)]
#![deny(rustdoc::missing_crate_level_docs)]
#![deny(rustdoc::broken_intra_doc_links)]
#![deny(rustdoc::private_intra_doc_links)]
#![cfg_attr(any(nightly_rustc, docsrs), feature(doc_cfg))]

pub mod command;
pub(crate) mod download_limiter;
pub mod error;
pub(crate) mod task_pool;

use std::str::FromStr;

use clap::Parser;
use clap_verbosity_flag::{InfoLevel, Verbosity};
pub use error::Error;
pub use error::Result;
use tracing_subscriber::filter::Directive;
use tracing_subscriber::EnvFilter;

use crate::command::Command;

/// Main CLI application.
///
/// Derives [`Parser`] to be constructible from command-line arguments through [`clap`].
#[derive(Debug, Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// Allows control of [`tracing`] verbosity.
    ///
    /// See [`execute`](Cli::execute) documentation for details.
    #[command(flatten)]
    pub verbose: Verbosity<InfoLevel>,

    /// Command to be executed.
    #[command(subcommand)]
    pub command: Command,
}

impl Cli {
    /// Execute our CLI program.
    ///
    /// This method parses the arguments, sets up [`tracing`] support and executes the appropriate
    /// command. If parsing results in an error, [`clap`] reports it automatically to the user.
    ///
    /// # Tracing support
    ///
    /// The level of verbosity for the program is controlled by the [`verbose`](Cli::verbose) flag (`-v`).
    /// By default, we print [`INFO`](tracing::Level::INFO) and above, but only for our own crate
    /// (not for dependent crates like `hyper`).
    ///
    /// It is possible to change verbosity in two ways:
    ///
    /// * Use the `--verbose` or `--quiet` command-line arguments when invoking the program. These
    ///   can be specified multiple times (e.g. `-vv` will boost it to [`TRACE`](tracing::Level::TRACE)).
    /// * Set the `RUST_LOG` environment variable. This will override any verbosity specified on the
    ///   command-line. The format is similar to that supported by the [`env_logger`] crate.
    ///   This can also be used to enable tracing for other modules (e.g. setting the environment
    ///   variable to `trace` will print everything, from all crates involved).
    ///
    /// [`env_logger`]: https://docs.rs/env_logger/latest/env_logger/
    pub async fn execute() -> Result<()> {
        let cli = Self::parse();

        let default_directive =
            Directive::from_str(&format!("{}={}", module_path!(), cli.verbose.log_level_filter()))
                .expect("default directive should be valid");
        let env_filter = EnvFilter::builder()
            .with_default_directive(default_directive)
            .from_env_lossy();
        tracing_subscriber::fmt().with_env_filter(env_filter).init();

        cli.command.execute().await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod cli {
        use clap::CommandFactory;

        use super::*;

        #[test]
        fn test_debug_assert() {
            // This is just a very basic test for our CLI as generated by `clap`.
            // Other tests will take the form of integration tests.
            Cli::command().debug_assert();
        }
    }
}
